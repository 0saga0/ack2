#!/usr/bin/perl

use strict;
use warnings;

use blib;
use App::Ack;
use Getopt::Long;
use File::Glob ':glob';

MAIN: {
    my @arg_sources = retrieve_arg_sources();

    my $opt = process_args( @arg_sources );
}


sub process_args {
    my @arg_sources = @_;

    # First get the argtypes

    Getopt::Long::Configure( 'no_ignore_case', 'pass_through', 'no_auto_abbrev' );
    # pass_through   => leave unrecognized command line arguments alone
    # no_auto_abbrev => otherwise -c is expanded and not left alone

    my @idirs;
    my @ifiles;
    my @types;

    my %type_arg_specs = (
        'type-add=s' => sub { shift; push @types, shift; },
        'type-set=s' => sub { shift; push @types, shift; },
    );
    my @leftovers;
    while ( @arg_sources ) {
        my ($source_name, $args) = splice( @arg_sources, 0, 2 );

        my $ret;
        if ( ref($args) ) {
            $ret = Getopt::Long::GetOptionsFromArray( $args, %type_arg_specs );
        }
        else {
            ($ret, $args) = Getopt::Long::GetOptionsFromString( $args, %type_arg_specs );
        }
        $ret || die "Return code $ret is false, but never should be";
        push( @leftovers, $source_name, $args );
    }

    Getopt::Long::Configure( 'no_pass_through' );

    my %opt;
    my %arg_specs = (
        1                   => sub { $opt{1} = $opt{m} = 1 },
        'A|after-context=i' => \$opt{after_context},
        'B|before-context=i'
                            => \$opt{before_context},
        'C|context:i'       => sub { shift; my $val = shift; $opt{before_context} = $opt{after_context} = ($val || 2) },
        'a|all-types'       => \$opt{all},
        'break!'            => \$opt{break},
        c                   => \$opt{count},
        'color|colour!'     => \$opt{color},
        'color-match=s'     => \$ENV{ACK_COLOR_MATCH},
        'color-filename=s'  => \$ENV{ACK_COLOR_FILENAME},
        'color-lineno=s'    => \$ENV{ACK_COLOR_LINENO},
        'column!'           => \$opt{column},
        count               => \$opt{count},
        'env!'              => sub { }, # ignore this option, it is handled beforehand
        f                   => \$opt{f},
        flush               => \$opt{flush},
        'follow!'           => \$opt{follow},
        'g=s'               => sub { shift; $opt{G} = shift; $opt{f} = 1 },
        'G=s'               => \$opt{G},
        'group!'            => sub { shift; $opt{heading} = $opt{break} = shift },
        'heading!'          => \$opt{heading},
        'h|no-filename'     => \$opt{h},
        'H|with-filename'   => \$opt{H},
        'i|ignore-case'     => \$opt{i},
        'ignore-directory|ignore-dir=s'
                            => sub { shift; push @idirs,  shift; },
        'ignore-file=s'     => sub { shift; push @ifiles, shift; },
        'invert-file-match' => \$opt{invert_file_match},
        'lines=s'           => sub { shift; my $val = shift; push @{$opt{lines}}, $val },
        'l|files-with-matches'
                            => \$opt{l},
        'L|files-without-matches'
                            => sub { $opt{l} = $opt{v} = 1 },
        'm|max-count=i'     => \$opt{m},
        'match=s'           => \$opt{regex},
        'n|no-recurse'      => \$opt{n},
        o                   => sub { $opt{output} = '$&' },
        'output=s'          => \$opt{output},
        'pager=s'           => \$opt{pager},
        'nopager'           => sub { $opt{pager} = undef },
        'passthru'          => \$opt{passthru},
        'print0'            => \$opt{print0},
        'Q|literal'         => \$opt{Q},
        'r|R|recurse'       => sub { $opt{n} = 0 },
        'show-types'        => \$opt{show_types},
        'smart-case!'       => \$opt{smart_case},
        'sort-files'        => \$opt{sort_files},
        'u|unrestricted'    => \$opt{u},
        'v|invert-match'    => \$opt{v},
        'w|word-regexp'     => \$opt{w},

        'version'           => sub { App::Ack::print_version_statement(); exit; },
        'help|?:s'          => sub { shift; App::Ack::show_help(@_); exit; },
        'help-types'        => sub { App::Ack::show_help_types(); exit; },
        'man'               => sub {
            require Pod::Usage;
            Pod::Usage::pod2usage({
                -verbose => 2,
                -exitval => 0,
            });
        }, # man sub
    );
    {use Data::Dumper; local $Data::Dumper::Sortkeys=1;
        print Dumper( \@idirs, \@ifiles, \@types, \@leftovers ) }

    while ( @leftovers ) {
        my ($source_name, $args) = splice( @leftovers, 0, 2 );

        my $ret;
        if ( ref($args) ) {
            $ret = Getopt::Long::GetOptionsFromArray( $args, %arg_specs );
        }
        else {
            $ret = Getopt::Long::GetOptionsFromString( $args, %arg_specs );
        }
        if ( !$ret ) {
            my $where = $source_name eq 'ARGV' ? 'on command line' : "in $source_name";
            App::Ack::die( "Invalid option $where" );
        }
    }
    {use Data::Dumper; local $Data::Dumper::Sortkeys=1;
        print Dumper( \%opt )}
}


sub retrieve_arg_sources {
    my @arg_sources;

    my @files = ( $ENV{ACKRC} );

    my @maybe_dirs;
    my @maybe_files;
    if ( $App::Ack::is_windows ) {
        @maybe_dirs  = ( $ENV{HOME}, $ENV{USERPROFILE} );
        @maybe_files = ( '.ackrc', '_ackrc' );
    }
    else {
        @maybe_dirs  = ( '~', $ENV{HOME} );
        @maybe_files = ( '.ackrc' );
    }
    CHECK_FILES: for my $maybe_dir ( grep { defined } @maybe_dirs ) {
        for my $maybe_file ( @maybe_files ) {
            my $file = "$maybe_dir/$maybe_file";
            my @lines = read_rcfile( $file );
            if ( @lines ) {
                push( @arg_sources, $file, \@lines );
                last CHECK_FILES;
            }
        }
    }

    if ( $ENV{ACK_OPTIONS} ) {
        push( @arg_sources, 'ACK_OPTIONS', $ENV{ACK_OPTIONS} );
    }

    push( @arg_sources, 'ARGV', [ @ARGV ] );

    return @arg_sources;
}

sub read_rcfile {
    my $file = shift;

    return unless defined $file && -e $file;

    my @lines;

    open( my $fh, '<', $file ) or App::Ack::die( "Unable to read $file: $!" );
    while ( my $line = <$fh> ) {
        chomp $line;
        $line =~ s/^\s+//;
        $line =~ s/\s+$//;

        next if $line eq '';
        next if $line =~ /^#/;

        push( @lines, $line );
    }

    return @lines;
}
