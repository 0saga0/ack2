#!/usr/bin/perl

use strict;
use warnings;

use 5.8.0;

use App::Ack ();
use App::Ack::ConfigLoader ();
use App::Ack::Filter ();
use App::Ack::Resource::Basic ();

use Carp ();

our $VERSION = '2.00a01';
# Check http://betterthangrep.com/ for updates

# These are all our globals.

MAIN: {
    if ( $App::Ack::VERSION ne $main::VERSION ) {
        App::Ack::die( "Program/library version mismatch\n\t$0 is $main::VERSION\n\t$INC{'App/Ack.pm'} is $App::Ack::VERSION" );
    }

    # Do preliminary arg checking;
    my $env_is_usable = 1;
    for ( @ARGV ) {
        last if ( $_ eq '--' );

        # Get the --thpppt checking out of the way.
        /^--th[pt]+t+$/ && App::Ack::_thpppt($_);

        # See if we want to ignore the environment. (Don't tell Al Gore.)
        if ( /^--(no)?env$/ ) {
            $env_is_usable = defined $1 ? 0 : 1;
        }
    }
    if ( !$env_is_usable ) {
        my @keys = ( 'ACKRC', grep { /^ACK_/ } keys %ENV );
        delete @ENV{@keys};
    }
    App::Ack::load_colors();

    if ( !@ARGV ) {
        App::Ack::show_help();
        exit 1;
    }

    main();
}

sub _compile_descend_filter {
    my ( $opt ) = @_;

    my $idirs = $opt->{idirs};
    return unless $idirs && @{$idirs};

    my %ignore_dirs;

    foreach my $idir (@{$idirs}) {
        if( $idir =~ /^(\w+),(.*)/ ) {
            if( $1 eq 'is') {
                $ignore_dirs{$2} = 1;
            }
            else {
                Carp::croak "Non-is filters are not yet supported for --ignore-dir";
            }
        }
        else {
            Carp::croak "invalid filter specification '$_'";
        }
    }

    return sub {
        return !exists $ignore_dirs{$_} && !exists $ignore_dirs{$File::Next::dir};
    };
}

sub _compile_file_filter {
    my ( $opt, $start ) = @_;

    my $ifiles = $opt->{ifiles};
    return unless $ifiles && @{$ifiles};

    my @ifiles_filters = map {
        my $filter;

        if($_ =~ /^(\w+),(.*)/) {
            $filter = App::Ack::Filter->create_filter($1, split(/,/, $2));
        } else {
            Carp::croak "invalid filter specification '$_'";
        }
        $filter
    } @{$ifiles};

    my $filters         = $opt->{'filters'} || [];
    my $inverse_filters = [ grep {  $_->is_inverted() } @{$filters} ];
    @{$filters}         =   grep { !$_->is_inverted() } @{$filters};

    my %is_member_of_starting_set = map {
        $_ => 1
    } @{$start};

    my $filter_re         = $opt->{G} ? qr/$opt->{G}/ : undef;
    my $invert_file_match = $opt->{invert_file_match};

    return sub {
        return 1 if $is_member_of_starting_set{ $File::Next::name };

        my $resource = App::Ack::Resource::Basic->new($File::Next::name);
        foreach my $filter (@ifiles_filters) {
            return 0 if $filter->filter($resource);
        }
        my $match_found = 1;
        if(@{$filters}) {
            $match_found = 0;

            foreach my $filter (@{$filters}) {
                if($filter->filter($resource)) {
                    $match_found = 1;
                    last;
                }
            }
        }
        # don't bother invoking inverse filters unless
        # we consider the current resource a match
        if( $match_found && @{$inverse_filters} ) {
            foreach my $filter ( @{$inverse_filters} ) {
                unless( $filter->filter( $resource ) ) {
                    $match_found = 0;
                    last;
                }
            }
        }
        if($match_found && defined($filter_re)) {
            $match_found = $File::Next::name =~ /$filter_re/;
            if($invert_file_match) {
                $match_found = !$match_found;
            }
        }
        return $match_found;
    };
}

sub main {
    my @arg_sources = App::Ack::retrieve_arg_sources();

    my $opt = App::Ack::ConfigLoader::process_args( @arg_sources );

    unless( defined $opt->{color} ) {
        $opt->{color} = !App::Ack::output_to_pipe();
    }

    my $resources;
    if ( $App::Ack::is_filter_mode ) {
        $resources    = App::Ack::Resources->from_stdin( $opt );
        $opt->{regex} = App::Ack::build_regex(shift @ARGV, $opt);
    }
    else {
        if( $opt->{f} || $opt->{lines} ) {
            if( $opt->{regex} ) {
                App::Ack::warn( "regex ($opt->{regex}) specified with -f or -g" );
                App::Ack::exit_from_ack( 0 ); # XXX the 0 is misleading
            }
        }
        else {
            $opt->{regex} = App::Ack::build_regex(shift @ARGV, $opt);
        }
        my @start = @ARGV;
        unless(@start == 1 && -f $start[0]) {
            $opt->{H} = 1;
        }
        @start = ('.') if not @start;
        foreach my $target (@start) {
            unless(-e $target) {
                App::Ack::warn( "$target: No such file or directory" );
            }
        }

        $opt->{file_filter}    = _compile_file_filter($opt, \@start);
        $opt->{descend_filter} = _compile_descend_filter($opt);


        $resources = App::Ack::Resources->from_argv( $opt, \@start );
    }
    App::Ack::set_up_pager( $opt->{pager} ) if defined $opt->{pager};

    my $print_filenames = $opt->{H};
    my $max_count       = $opt->{m};
    my $ors             = $opt->{print0} ? "\0" : "\n";

    my $nmatches = 0;
RESOURCES:
    while ( my $resource = $resources->next ) {
        # XXX this variable name combined with what we're trying
        # to do makes no sense.
        if ( $opt->{f} ) {
            # XXX printing should probably happen inside of App::Ack
            print $resource->name, $ors;
            ++$nmatches;
            last RESOURCES if defined($max_count) && $nmatches >= $max_count;
        }
        elsif( $opt->{lines} ) {
            my $print_filename = $opt->{H} && !$opt->{h};

            my %line_numbers;
            foreach my $line ( @{ $opt->{lines} } ) {
                my @lines             = split /,/, $line;
                @lines                = map {
                    /^(\d+)-(\d+)$/
                        ? ( $1 .. $2 )
                        : $_
                } @lines;
                @line_numbers{@lines} = (1) x @lines;
            }
            while( $resource->next_text ) {
                chomp;

                if( $line_numbers{$.} ) {
                    my @line_parts;

                    if($print_filename) {
                        push @line_parts, $resource->name, $.;
                    }
                    push @line_parts, $_;
                    App::Ack::print( join( ':', @line_parts ), $ors );
                }
            }
        }
        elsif( $opt->{count} ) {
            my $matches_for_this_file = App::Ack::count_matches_in_resource( $resource, $opt );
            if( !$opt->{l} || $matches_for_this_file > 0) {
                if($print_filenames) {
                    # XXX printing should probably happen inside of App::Ack
                    print $resource->name, ':', $matches_for_this_file, $ors;
                }
                else {
                    # XXX printing should probably happen inside of App::Ack
                    print $matches_for_this_file, $ors;
                }
            }
        }
        elsif( $opt->{l} ) {
            my $matches = App::Ack::resource_has_match( $resource, $opt );
            my $invert  = $opt->{v};

            if( $invert ? !$matches : $matches ) {
                # XXX printing should probably happen inside of App::Ack
                print $resource->name, $ors;
                ++$nmatches;
            }
        }
        else {
            $nmatches += App::Ack::print_matches_in_resource( $resource, $opt );
        }
    }

    close $App::Ack::fh;
    App::Ack::exit_from_ack( $nmatches );
}
