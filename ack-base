#!/usr/bin/perl

use strict;
use warnings;

use 5.8.0;

use App::Ack ();
use App::Ack::ConfigLoader ();
use App::Ack::Filter ();
use App::Ack::Resource::Basic ();

use Carp ();

our $VERSION = '2.00a01';
# Check http://betterthangrep.com/ for updates

# These are all our globals.

MAIN: {
    if ( $App::Ack::VERSION ne $main::VERSION ) {
        App::Ack::die( "Program/library version mismatch\n\t$0 is $main::VERSION\n\t$INC{'App/Ack.pm'} is $App::Ack::VERSION" );
    }

    # Do preliminary arg checking;
    my $env_is_usable = 1;
    for ( @ARGV ) {
        last if ( $_ eq '--' );

        # Get the --thpppt checking out of the way.
        /^--th[pt]+t+$/ && App::Ack::_thpppt($_);

        # See if we want to ignore the environment. (Don't tell Al Gore.)
        if ( /^--(no)?env$/ ) {
            $env_is_usable = defined $1 ? 0 : 1;
        }
    }
    if ( !$env_is_usable ) {
        my @keys = ( 'ACKRC', grep { /^ACK_/ } keys %ENV );
        delete @ENV{@keys};
    }
    App::Ack::load_colors();

    if ( !@ARGV ) {
        App::Ack::show_help();
        exit 1;
    }

    main();
}

sub _compile_descend_filter {
    my ( $opt ) = @_;

    my $idirs = $opt->{idirs};
    return unless $idirs && @{$idirs};

    my @idirs_filters = map {
        my $filter;

        if($_ =~ /^(\w+),(.*)/) {
            $filter = App::Ack::Filter->create_filter($1, split(/,/, $2));
        } else {
            Carp::croak "invalid filter specification '$_'";
        }
        $filter;
    } @{$idirs};

    return sub {
        my $resource = App::Ack::Resource::Basic->new($File::Next::dir);
        foreach my $filter (@idirs_filters) {
            return 0 if $filter->filter($resource);
        }
        return 1;
    };
}

sub _compile_file_filter {
    my ( $opt ) = @_;

    my $ifiles = $opt->{ifiles};
    return unless $ifiles && @{$ifiles};

    my @ifiles_filters = map {
        my $filter;

        if($_ =~ /^(\w+),(.*)/) {
            $filter = App::Ack::Filter->create_filter($1, split(/,/, $2));
        } else {
            Carp::croak "invalid filter specification '$_'";
        }
        $filter
    } @{$ifiles};

    return sub {
        my $resource = App::Ack::Resource::Basic->new($File::Next::name);
        foreach my $filter (@ifiles_filters) {
            return 0 if $filter->filter($resource);
        }
        return 1;
    };
}

sub main {
    my @arg_sources = App::Ack::retrieve_arg_sources();

    my $opt = App::Ack::ConfigLoader::process_args( @arg_sources );

    my $resources;
    if ( $App::Ack::is_filter_mode ) {
        # XXX $resources = App::Ack::resources_iterator_for_standard_input_only();
    }
    else {
        my @start = @ARGV;
        $opt->{regex} = shift @ARGV;
        @start = ('.') if not @start;

        $opt->{file_filter}    = _compile_file_filter($opt);
        $opt->{descend_filter} = _compile_descend_filter($opt);

        $resources = App::Ack::Resources->from_argv( $opt, \@start );
    }
    App::Ack::set_up_pager( $opt->{pager} ) if defined $opt->{pager};

    my $nmatches = 0;
RESOURCES:
    while ( my $resource = $resources->next ) {
        if(my $filters = $opt->{'filters'}) {
            if(@{$filters}) {
                my $match_found = 0;

                foreach my $filter (@{$filters}) {
                    if($filter->filter($resource)) {
                        $match_found = 1;
                        last;
                    }
                }
                next RESOURCES unless $match_found;
            }
        }
        if ( $opt->{f} ) {
            print $resource->name, "\n";
            ++$nmatches;
        }
        if( $opt->{l} ) {
            my $matches = App::Ack::resource_has_match( $resource, $opt );
            my $invert  = $opt->{v};

            if( $invert ? !$matches : $matches ) {
                print $resource->name, "\n";
                ++$nmatches;
            }
        } else {
            $nmatches += App::Ack::print_matches_in_resource( $resource, $opt );
        }
#       elsif ( $opt->{g} ) {
#           if ( App::Ack::resource_name_matches( $resource, $opt ) ) {
#               print $resource->name, "\n";
#               ++$nmatches;
#           }
#       }
#       elsif ( $opt->{l} || $opt->{count} ) {
#           if ( App::Ack::resource_has_match( $resource, $opt ) ) {
#               print $resource->name, "\n";
#               ++$nmatches;
#           }
#       }
#       else {
#       }
    }

    close $App::Ack::fh;
    App::Ack::exit_from_ack( $nmatches );
}
