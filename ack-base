#!/usr/bin/perl

use strict;
use warnings;

use 5.8.0;

use App::Ack ();
use App::Ack::ConfigLoader ();
use App::Ack::Filter ();
use App::Ack::Resource::Basic ();

use Carp ();

our $VERSION = '2.00a01';
# Check http://betterthangrep.com/ for updates

# These are all our globals.

MAIN: {
    if ( $App::Ack::VERSION ne $main::VERSION ) {
        App::Ack::die( "Program/library version mismatch\n\t$0 is $main::VERSION\n\t$INC{'App/Ack.pm'} is $App::Ack::VERSION" );
    }

    # Do preliminary arg checking;
    my $env_is_usable = 1;
    for ( @ARGV ) {
        last if ( $_ eq '--' );

        # Get the --thpppt checking out of the way.
        /^--th[pt]+t+$/ && App::Ack::_thpppt($_);

        # See if we want to ignore the environment. (Don't tell Al Gore.)
        if ( /^--(no)?env$/ ) {
            $env_is_usable = defined $1 ? 0 : 1;
        }
    }
    if ( !$env_is_usable ) {
        my @keys = ( 'ACKRC', grep { /^ACK_/ } keys %ENV );
        delete @ENV{@keys};
    }
    App::Ack::load_colors();

    if ( !@ARGV ) {
        App::Ack::show_help();
        exit 1;
    }

    main();
}

sub _compile_descend_filter {
    my ( $opt ) = @_;

    my $idirs = $opt->{idirs};
    return unless $idirs && @{$idirs};

    my @idirs_filters = map {
        my $filter;

        if($_ =~ /^(\w+),(.*)/) {
            $filter = App::Ack::Filter->create_filter($1, split(/,/, $2));
        } else {
            Carp::croak "invalid filter specification '$_'";
        }
        $filter;
    } @{$idirs};

    return sub {
        my $resource = App::Ack::Resource::Basic->new($File::Next::dir);
        foreach my $filter (@idirs_filters) {
            return 0 if $filter->filter($resource);
        }
        return 1;
    };
}

sub _compile_file_filter {
    my ( $opt, $start ) = @_;

    my $ifiles = $opt->{ifiles};
    return unless $ifiles && @{$ifiles};

    my @ifiles_filters = map {
        my $filter;

        if($_ =~ /^(\w+),(.*)/) {
            $filter = App::Ack::Filter->create_filter($1, split(/,/, $2));
        } else {
            Carp::croak "invalid filter specification '$_'";
        }
        $filter
    } @{$ifiles};

    my $filters = $opt->{'filters'} || [];

    my %is_member_of_starting_set = map {
        $_ => 1
    } @{$start};

    my $filter_re = $opt->{G} ? qr/$opt->{G}/ : undef;

    return sub {
        return 1 if $is_member_of_starting_set{ $File::Next::name };

        my $resource = App::Ack::Resource::Basic->new($File::Next::name);
        foreach my $filter (@ifiles_filters) {
            return 0 if $filter->filter($resource);
        }
        my $match_found = 1;
        if(@{$filters}) {
            $match_found = 0;

            foreach my $filter (@{$filters}) {
                if($filter->filter($resource)) {
                    $match_found = 1;
                    last;
                }
            }
        }
        return $match_found &&
            ( defined($filter_re) ? $File::Next::name =~ /$filter_re/ : 1 );
    };
}

sub main {
    my @arg_sources = App::Ack::retrieve_arg_sources();

    my $opt = App::Ack::ConfigLoader::process_args( @arg_sources );

    my $resources;
    if ( $App::Ack::is_filter_mode ) {
        $resources    = App::Ack::Resources->from_stdin( $opt );
        $opt->{regex} = shift @ARGV;
    }
    else {
        unless( $opt->{f} ) {
            $opt->{regex} = shift @ARGV;
        }
        my @start = @ARGV;
        unless(@start == 1 && -f $start[0]) {
            $opt->{H} = 1;
        }
        @start = ('.') if not @start;
        foreach my $target (@start) {
            unless(-e $target) {
                App::Ack::warn( "$target: No such file or directory" );
            }
        }

        $opt->{file_filter}    = _compile_file_filter($opt, \@start);
        $opt->{descend_filter} = _compile_descend_filter($opt);


        $resources = App::Ack::Resources->from_argv( $opt, \@start );
    }
    App::Ack::set_up_pager( $opt->{pager} ) if defined $opt->{pager};

    my $print_filenames = $opt->{H};
    my $max_count       = $opt->{m};

    my $nmatches = 0;
RESOURCES:
    while ( my $resource = $resources->next ) {
        # XXX this variable name combined with what we're trying
        # to do makes no sense.
        if ( $opt->{f} ) {
            # XXX printing should probably happen inside of App::Ack
            print $resource->name, "\n";
            ++$nmatches;
            last RESOURCES if defined($max_count) && $nmatches >= $max_count;
        }
        elsif( $opt->{count} ) {
            my $matches_for_this_file = App::Ack::count_matches_in_resource( $resource, $opt );
            if( !$opt->{l} || $matches_for_this_file > 0) {
                if($print_filenames) {
                    # XXX printing should probably happen inside of App::Ack
                    print $resource->name, ':', $matches_for_this_file, "\n";
                }
                else {
                    # XXX printing should probably happen inside of App::Ack
                    print $matches_for_this_file, "\n";
                }
            }
        }
        elsif( $opt->{l} ) {
            my $matches = App::Ack::resource_has_match( $resource, $opt );
            my $invert  = $opt->{v};

            if( $invert ? !$matches : $matches ) {
                # XXX printing should probably happen inside of App::Ack
                print $resource->name, "\n";
                ++$nmatches;
            }
        }
        else {
            $nmatches += App::Ack::print_matches_in_resource( $resource, $opt );
        }
    }

    close $App::Ack::fh;
    App::Ack::exit_from_ack( $nmatches );
}
